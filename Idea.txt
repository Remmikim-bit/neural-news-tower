import React, { useState, useEffect, useRef, useMemo } from 'react';
import { 
  BookOpen, Network, Search, Filter, Lightbulb, X, MousePointer2
} from 'lucide-react';

// --- Inline UI Components ---

const GlassContainer = ({ children, className = "" }) => (
  <div className={`backdrop-blur-xl bg-[#1e1e1e] border border-[#333] rounded-lg shadow-2xl overflow-hidden ${className}`}>
    {children}
  </div>
);

const Badge = ({ children, color = "gray" }) => {
  const colors = {
    gray: "bg-gray-800 text-gray-300 border-gray-700",
    purple: "bg-purple-900/30 text-purple-300 border-purple-800",
    green: "bg-emerald-900/30 text-emerald-300 border-emerald-800",
    blue: "bg-blue-900/30 text-blue-300 border-blue-800",
    amber: "bg-amber-900/30 text-amber-300 border-amber-800",
  };
  return (
    <span className={`px-2 py-0.5 rounded text-[10px] font-medium border ${colors[color] || colors.gray}`}>
      {children}
    </span>
  );
};

// --- Custom Physics Engine (Stable & User Defined Logic) ---

const useStableSimulation = (initialNodes, initialLinks, width, height) => {
  const [nodes, setNodes] = useState([]);
  
  // Simulation Constants matching user requirements
  const BASE_REPULSION = 500; // Base constant for repulsion
  const BASE_ATTRACTION = 0.01; // Base spring constant
  const REST_LENGTH = 80; // Ideal distance
  const CENTER_GRAVITY = 0.02; // Pull to center
  const DAMPING = 0.8; // Friction

  // 1. Initialization (Only runs once or when data topology changes)
  useEffect(() => {
    // Check if we already have nodes to prevent reset on re-renders
    if (nodes.length > 0 && nodes.length === initialNodes.length) return;

    const initializedNodes = initialNodes.map((node, i) => {
      // Spiral layout for initial placement to prevent overlap
      const angle = 0.5 * i;
      const radius = 10 + 5 * i;
      return {
        ...node,
        x: width / 2 + Math.cos(angle) * radius,
        y: height / 2 + Math.sin(angle) * radius,
        vx: 0,
        vy: 0
      };
    });
    setNodes(initializedNodes);
  }, [initialNodes, width, height]); // Intentionally removed 'nodes' from dependency to avoid loop

  // 2. Physics Tick Loop
  useEffect(() => {
    if (nodes.length === 0) return;

    let animationFrameId;
    
    // Using a ref for nodes inside the loop to avoid state dependency issues
    let currentNodes = nodes; 

    const tick = () => {
      // Calculate Forces
      const nextNodes = currentNodes.map(n => ({ ...n }));
      let maxVelocity = 0;

      // A. Repulsion: F ~ (SizeA + SizeB) / dist^2
      for (let i = 0; i < nextNodes.length; i++) {
        for (let j = i + 1; j < nextNodes.length; j++) {
          const n1 = nextNodes[i];
          const n2 = nextNodes[j];
          
          const dx = n1.x - n2.x;
          const dy = n1.y - n2.y;
          const distSq = dx * dx + dy * dy || 1;
          const dist = Math.sqrt(distSq);

          // Custom Logic: Repulsion proportional to sum of sizes (val)
          // Larger nodes push each other away more strongly
          const sizeFactor = (n1.val + n2.val); 
          const force = (BASE_REPULSION * sizeFactor) / distSq;
          
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;

          n1.vx += fx;
          n1.vy += fy;
          n2.vx -= fx;
          n2.vy -= fy;
        }
      }

      // B. Attraction: F ~ Thickness * (dist - rest)
      initialLinks.forEach(link => {
        const source = nextNodes.find(n => n.id === link.source);
        const target = nextNodes.find(n => n.id === link.target);
        
        if (source && target) {
          const dx = target.x - source.x;
          const dy = target.y - source.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          
          // Custom Logic: Attraction proportional to link thickness (value)
          // Thicker links pull nodes closer/tighter
          const linkThickness = link.value || 1; 
          const force = (dist - REST_LENGTH) * (BASE_ATTRACTION * linkThickness);
          
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;

          source.vx += fx;
          source.vy += fy;
          target.vx -= fx;
          target.vy -= fy;
        }
      });

      // C. Update Positions & Damping
      nextNodes.forEach(node => {
        // Center Gravity (Keeps graph centered)
        node.vx += (width / 2 - node.x) * CENTER_GRAVITY;
        node.vy += (height / 2 - node.y) * CENTER_GRAVITY;

        // Apply Velocity
        node.x += node.vx;
        node.y += node.vy;

        // Apply Damping (Friction)
        node.vx *= DAMPING;
        node.vy *= DAMPING;

        maxVelocity = Math.max(maxVelocity, Math.abs(node.vx), Math.abs(node.vy));
      });

      currentNodes = nextNodes;
      
      // Stop simulation if movement is negligible (Energy saving & Stability)
      if (maxVelocity > 0.1) {
        setNodes(currentNodes);
        animationFrameId = requestAnimationFrame(tick);
      } else {
        setNodes(currentNodes); // Final update
      }
    };

    tick();

    return () => cancelAnimationFrame(animationFrameId);
  }, [width, height, initialLinks]); // Re-run only if dimensions or topology changes

  return nodes;
};

const KnowledgeGraph = ({ data, onNodeClick }) => {
  const containerRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });
  const [hoveredNode, setHoveredNode] = useState(null);

  // Use stable simulation
  const nodes = useStableSimulation(data.nodes, data.links, dimensions.width, dimensions.height);

  useEffect(() => {
    if (!containerRef.current) return;
    const resizeObserver = new ResizeObserver(entries => {
      for (let entry of entries) {
        setDimensions({
          width: entry.contentRect.width,
          height: entry.contentRect.height
        });
      }
    });
    resizeObserver.observe(containerRef.current);
    return () => resizeObserver.disconnect();
  }, []);

  // Is node connected to hovered node?
  const isConnected = (nodeId) => {
    if (!hoveredNode) return false;
    return hoveredNode === nodeId || 
           data.links.some(l => (l.source === hoveredNode && l.target === nodeId) || (l.target === hoveredNode && l.source === nodeId));
  };

  return (
    <div 
      ref={containerRef} 
      className="w-full h-full relative overflow-hidden bg-[#111] select-none"
    >
      <svg width="100%" height="100%">
        {/* Links */}
        {data.links.map((link, i) => {
          const source = nodes.find(n => n.id === link.source);
          const target = nodes.find(n => n.id === link.target);
          if (!source || !target) return null;
          
          const isDimmed = hoveredNode && !(source.id === hoveredNode || target.id === hoveredNode);
          const isHighlighted = hoveredNode && (source.id === hoveredNode || target.id === hoveredNode);
          const strokeWidth = link.value ? Math.sqrt(link.value) : 1; // Visual width based on value

          return (
            <line
              key={i}
              x1={source.x}
              y1={source.y}
              x2={target.x}
              y2={target.y}
              stroke={isHighlighted ? "#8b5cf6" : "#444"}
              strokeWidth={strokeWidth}
              opacity={isDimmed ? 0.05 : (isHighlighted ? 0.8 : 0.2)}
              className="transition-all duration-300"
            />
          );
        })}
        
        {/* Nodes */}
        {nodes.map((node) => {
          const isDimmed = hoveredNode && !isConnected(node.id);
          const isHovered = hoveredNode === node.id;
          const isSelected = false; // Simplified

          return (
            <g 
              key={node.id} 
              transform={`translate(${node.x},${node.y})`}
              onMouseEnter={() => setHoveredNode(node.id)}
              onMouseLeave={() => setHoveredNode(null)}
              onClick={(e) => {
                e.stopPropagation();
                onNodeClick(node);
              }}
              style={{ opacity: isDimmed ? 0.1 : 1, transition: 'opacity 0.2s' }}
              className="cursor-pointer"
            >
              {/* Core Node */}
              <circle 
                r={node.val} 
                fill={node.color} 
                className="transition-all duration-300"
              />
              
              {/* Hover Highlight Ring */}
              <circle 
                r={node.val + 4} 
                fill="none" 
                stroke={node.color} 
                strokeWidth="1.5" 
                opacity={isHovered ? 0.6 : 0}
                className="transition-all duration-300"
              />

              {/* Label */}
              <text 
                dy={node.val + 12} 
                textAnchor="middle" 
                fill={isHovered ? "#fff" : "#666"} 
                fontSize={isHovered ? "12" : "10"} 
                fontWeight={isHovered ? "bold" : "normal"}
                className="pointer-events-none transition-all duration-300"
                style={{ textShadow: isHovered ? '0 1px 4px rgba(0,0,0,0.8)' : 'none' }}
              >
                {node.name}
              </text>
            </g>
          );
        })}
      </svg>
      
      {/* Legend / Info */}
      <div className="absolute bottom-6 right-6 flex flex-col gap-2 pointer-events-none">
         <div className="bg-[#222]/80 p-2 rounded-md border border-[#333] text-xs text-gray-500 backdrop-blur">
           Physics: Repulsion ∝ Node Size | Attraction ∝ Link Thickness
         </div>
      </div>
    </div>
  );
};

// --- Dashboard & Data ---

export default function App() {
  const [activeTab, setActiveTab] = useState('graph');
  const [selectedNode, setSelectedNode] = useState(null);
  
  // Data Wrapped in useMemo to prevent re-renders triggering physics reset
  // Added 'value' to links to demonstrate the attraction logic
  const graphData = useMemo(() => ({
    nodes: [
      { id: 'n1', name: 'Gamification', val: 15, color: '#a78bfa', group: 'core' }, // Large Node -> High Repulsion
      { id: 'n2', name: 'Reward Systems', val: 6, color: '#a78bfa', group: 'core' },
      { id: 'n3', name: 'Motivation', val: 8, color: '#f472b6', group: 'psych' },
      { id: 'n4', name: 'Self-Determination', val: 8, color: '#f472b6', group: 'psych' },
      { id: 'n5', name: 'Meditation', val: 10, color: '#34d399', group: 'app' },
      { id: 'n6', name: 'Headspace', val: 6, color: '#34d399', group: 'app' },
      { id: 'n7', name: 'User Behavior', val: 8, color: '#fbbf24', group: 'user' },
      { id: 'n8', name: 'Habits', val: 5, color: '#fbbf24', group: 'user' },
      { id: 'n9', name: 'Narrative', val: 7, color: '#60a5fa', group: 'story' },
      { id: 'n10', name: 'Player Journey', val: 7, color: '#60a5fa', group: 'story' },
      { id: 'n11', name: 'Flow State', val: 5, color: '#9ca3af', group: 'gap' },
    ],
    links: [
      { source: 'n1', target: 'n2', value: 5 }, // Thick link -> High Attraction
      { source: 'n1', target: 'n7', value: 3 },
      { source: 'n1', target: 'n9', value: 2 },
      { source: 'n3', target: 'n4', value: 4 },
      { source: 'n4', target: 'n2', value: 2 },
      { source: 'n5', target: 'n6', value: 5 },
      { source: 'n6', target: 'n7', value: 3 },
      { source: 'n8', target: 'n7', value: 2 },
      { source: 'n9', target: 'n10', value: 4 },
      { source: 'n11', target: 'n3', value: 1 }, // Thin link -> Low Attraction
    ]
  }), []);

  return (
    <div className="h-screen bg-[#111] text-gray-200 font-sans flex flex-col overflow-hidden">
      
      {/* Header */}
      <nav className="h-12 border-b border-[#333] bg-[#1e1e1e] flex items-center justify-between px-4 shrink-0">
        <div className="flex items-center gap-2">
          <Network className="w-4 h-4 text-purple-400" />
          <span className="font-semibold text-sm tracking-tight text-gray-200">Neural Graph View</span>
        </div>
      </nav>

      {/* Main Workspace */}
      <div className="flex-1 flex overflow-hidden">
        
        {/* Left: Graph Area */}
        <div className="flex-1 relative">
          <KnowledgeGraph data={graphData} onNodeClick={setSelectedNode} />
          
          <div className="absolute top-4 left-4">
             <div className="flex items-center gap-2 bg-[#1e1e1e] border border-[#333] rounded px-2 py-1.5 shadow-lg">
                <Search className="w-3 h-3 text-gray-500" />
                <input 
                  type="text" 
                  placeholder="Search..." 
                  className="bg-transparent border-none outline-none text-xs text-gray-300 w-40 placeholder:text-gray-600"
                />
             </div>
          </div>
        </div>

        {/* Right: Sidebar */}
        <div className="w-80 border-l border-[#333] bg-[#161616] flex flex-col">
          {selectedNode ? (
            <div className="p-4 space-y-4 animate-in slide-in-from-right duration-200">
              <div className="flex justify-between items-start">
                <h2 className="text-xl font-bold text-white">{selectedNode.name}</h2>
                <button onClick={() => setSelectedNode(null)} className="text-gray-500 hover:text-white">
                  <X className="w-4 h-4" />
                </button>
              </div>

              <div className="space-y-4">
                <div className="p-3 bg-[#1e1e1e] rounded border border-[#333]">
                   <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-2 flex justify-between">
                     <span>Node Physics</span>
                     <span className="text-purple-400">Stable</span>
                   </div>
                   <div className="grid grid-cols-2 gap-2 text-xs text-gray-400">
                     <div className="bg-[#111] p-2 rounded">
                       <span className="block text-gray-600">Size (Repulsion)</span>
                       <span className="text-lg font-mono text-gray-200">{selectedNode.val}</span>
                     </div>
                     <div className="bg-[#111] p-2 rounded">
                       <span className="block text-gray-600">Group</span>
                       <span className="text-gray-200 capitalize">{selectedNode.group}</span>
                     </div>
                   </div>
                </div>

                <div className="p-3 bg-[#1e1e1e] rounded border border-[#333]">
                   <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-1">Context</div>
                   <p className="text-xs text-gray-400 leading-relaxed">
                     <span className="text-purple-300">{selectedNode.name}</span> plays a key role in the network structure.
                   </p>
                </div>

                <button className="w-full py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded text-xs text-gray-300 flex items-center justify-center gap-2 transition-colors">
                  <BookOpen className="w-3 h-3" />
                  View Note
                </button>
              </div>
            </div>
          ) : (
            <div className="p-6 flex flex-col items-center justify-center h-full text-center opacity-50">
              <MousePointer2 className="w-8 h-8 text-gray-600 mb-2" />
              <p className="text-sm text-gray-500">Select a node to inspect</p>
            </div>
          )}

          <div className="mt-auto border-t border-[#333] p-4 bg-[#1e1e1e]">
            <div className="flex items-center gap-2 mb-3">
              <Lightbulb className="w-3 h-3 text-amber-500" />
              <span className="text-xs font-semibold text-gray-300">Insights</span>
            </div>
            <div className="text-xs text-gray-400 leading-snug">
              Gap detected between <span className="text-emerald-400">Health</span> and <span className="text-purple-400">Game Design</span> clusters.
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}